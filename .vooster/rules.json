{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 개요\n주식회사 바이렉스의 B2B 제품 포털 웹사이트를 구축한다. 2,000개 이상의 제품 정보를 체계적으로 제공하고, 복잡한 필터링·검색 기능을 통해 B2B 담당자가 신속히 최적 제품을 찾을 수 있도록 지원한다. Next.js와 Supabase 기반의 효율적인 코드 구조로 개발·유지보수 비용을 절감하고, 확장성 높은 플랫폼을 제공한다.\n\n## 2. 문제 정의\n- 기존 바이렉스 웹 채널은 제품 수가 많음에도 불구하고 복수 파라미터별 필터링·검색이 어려워 B2B 담당자가 원하는 제품을 찾기 힘듦  \n- 상세 페이지 요소와 리스트 필터 파라미터가 상이해 정보 일관성이 부족  \n- 관리자가 대규모 제품 데이터를 수작업으로 관리해 운영 효율이 낮음  \n- 경쟁사 대비 현대적 UX·반응속도가 떨어져 신뢰도·매출 전환률 감소\n\n## 3. 목표 및 목적\n- 1차 목표: 2,000+ 제품의 고성능 다중 필터링·검색 제공\n- 2차 목표: 유지보수가 쉬운 컴포넌트 아키텍처 설계  \n- 성공 지표  \n  - 제품 검색 성공률 ≥ 90% (3회 이하 클릭/스크롤)  \n  - 페이지 로딩 2초 이하 (P95)  \n  - 제품 문의 전환율 15%↑  \n  - 관리자 데이터 입력 시간 40%↓  \n\n## 4. 대상 사용자\n### 주요 사용자\n- 국내·해외 B2B 구매 담당자 및 엔지니어  \n  - 연령 25~50세, 데스크탑·모바일 혼용  \n  - 빠른 스펙 비교, 상품별 관련 데이터시트, 스펙표 등 자료 다운로드 (상품마다 다르게 DB가 준비되어있음), 견적 문의, 뉴스레터 신청(이메일 입력) 필요\n### 부차적 사용자\n- 바이렉스 내부 영업팀·마케팅팀  \n- 파트너사 유통·AS 팀\n\n## 5. 사용자 스토리\n- “B2B 구매 담당자로서, 여러 파라미터로 제품을 필터링해 최적 제품을 즉시 찾고 싶다.”\n- “엔지니어로서, 상세 페이지에서 다이어그램·데이터시트·규격 비교를 보고 싶다.”\n- “마케터로서, 특정 산업군 방문자 행동 데이터를 분석해 캠페인을 최적화하고 싶다.”\n- “관리자로서, 대량 CSV 업로드로 제품 정보를 빠르게 갱신하고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 제품 카탈로그 & 다중 필터링  \n   - 파라미터 유형: partnumber, series 등 공통요소들과, 각 상품 카테고리별로 상이한 파라미터 >= 10\n   - AND/OR 조합 필터, 슬라이더 기반 필터, 체크박스 기반 필터, 필터링 시 URL 파라미터에 적용 필요\n   - 각 상품 파라미터에 신제품 boolen DB값이 true인 경우, 상품 리스트에서 가장 상단에 위치시키며, 'NEW' badge 디자인을 추가\n   - 헤더 내에 전체 상품 검색을 위한 검색 bar 존재, partnumber / series 등으로 검색 필요\n   - 상품 이미지 등 관련 정적 DB들의 쉬운 관리 필요\n   - 메인페이지에 워드프레스로 제작된 블로그의 글들을 실시간으로 연동 필요\n   - 수반되는 API 응답 ≤ 300ms\n\n2. 제품 상세 페이지  \n   - 리스트 필터 파라미터를 포함한 그 외 파라미터들을 추가적으로 표시 (상세페이지에서만 보이는 파라미터 DB가 존재. 해당 파라미터는 제품 DB의 series의 ID와 연동되어 관리\n   - 유사 제품 제안, PDF 다운로드, 문의 폼 통합  \n   - SEO 메타 태그 자동 생성\n\n3. 관리자 CMS  \n   - Supabase 테이블 연동, 역할 기반 접근 제어  \n   - CSV/Excel 일괄 업로드, 버전 관리, 에러 로그\n\n4. 글로벌 반응형 UI  \n   - Next.js + Tailwind 기반, 데스크탑·태블릿·모바일 대응  \n   - Lighthouse 접근성 점수 90↑\n\n### 보조 기능(제안)\n- 다국어(i18n) 지원 (KR/EN/JP)  \n- AI 기반 제품 추천(Phase 3)  \n- 즐겨찾기·비교 리스트  \n- ElasticSearch 연동 자동 완성  \n- Google Tag Manager, GA4 이벤트 추적 대시보드  \n- 문의/견적 CRM 연동(Salesforce, HubSpot)\n\n## 7. 비기능 요구사항\n- 성능: 초과 2,000제품·50k 필터 조합에서도 <2초 렌더  \n- 보안: Supabase RLS, OAuth2 SSO, WAF 적용  \n- 사용성: WCAG 2.1 AA, 키보드 탐색 완전 지원  \n- 확장성: 멀티리전 DB, CDN 캐싱, 모듈화된 Next.js 구조  \n- 호환성: 최신 Chrome, Edge, Safari, Firefox, iOS14+, Android10+\n\n## 8. 기술 고려사항\n- 아키텍처: Next.js(SSR/SCSR 하이브리드) + Supabase(Postgres, Auth, Edge Functions)  \n- 인프라: Vercel 배포, Cloudflare CDN, GitHub Actions CI/CD  \n- 데이터: 제품 테이블, 파라미터 메타테이블, 다국어 번역 테이블  \n- 외부 연동: Stripe(결제 옵션 보류), SendGrid(이메일), Elasticsearch(검색)  \n\n## 9. 성공 지표(KPI)\n- 월간 사용자(MAU) 20%↑ 6개월 내  \n- 평균 세션 길이 3분↑  \n- 제품 문의 리드 수 1.5배↑  \n- 서버 오류율 <0.1%  \n- Lighthouse 성능 ≥ 90점\n\n## 10. 일정 및 마일스톤\n- Phase 1 (M+0~M+3): MVP  \n  - 카탈로그, 필터링, 상세 페이지, 기본 CMS, KR UI\n- Phase 2 (M+4~M+6): 고도화  \n  - 다국어, 즐겨찾기, GA4, Edge caching, SEO\n- Phase 3 (M+7~M+9): 확장  \n  - AI 추천, CRM·결제 연동, 오프라인 전시 연계 기능\n\n## 11. 리스크 및 대응\n- 대량 데이터 성능 저하 → 인덱스 튜닝, 캐싱 계층 적용  \n- 필터 로직 복잡도 → Pre-computed 필터 매트릭스, SSG fallback  \n- 내부 리소스 부족 → 파트너 에이전시 협업, 스프린트 당 일정 버퍼 확보  \n- 사용자 채택 저조 → 온보딩 가이드, 검색 로그 기반 UX 개선\n\n## 12. 향후 과제\n- PWA 오프라인 브로슈어 모드  \n- AR/VR 제품 3D 뷰어  \n- ESG·친환경 지표 필터 추가  \n- 파트너사 API 마켓플레이스 구축",
      "writedAt": "2025-07-30T04:09:10.137Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 명세서 (TRD)\n\n## 1. 실행 기술 요약\n- **프로젝트 개요**: 본 문서는 주식회사 바이렉스의 B2B 제품 포털 웹사이트 구축을 위한 기술적 요구사항을 정의합니다. Next.js와 Supabase를 기반으로, 2,000개 이상의 제품에 대한 고성능 필터링 및 검색 기능을 제공하고, 비개발자도 쉽게 콘텐츠를 관리할 수 있는 시스템을 구축하는 것을 목표로 합니다.\n- **핵심 기술 스택**: 프론트엔드는 Next.js와 Tailwind CSS, 백엔드 및 데이터베이스는 Supabase(PostgreSQL, Auth, Edge Functions)를 사용합니다. 배포는 Vercel을 통해 자동화하여 개발 및 운영 효율성을 극대화합니다.\n- **주요 기술 목표**: 95퍼센타일(P95) 기준 2초 이내의 페이지 로딩 속도, 300ms 이내의 API 응답 시간을 달성합니다. 또한, 모듈화된 아키텍처를 통해 유지보수 비용을 절감하고 향후 기능 확장에 유연하게 대응합니다.\n- **핵심 기술 가정**: 모든 인프라는 Vercel과 Supabase의 관리형 서비스를 활용하여 서버 관리 부담을 최소화합니다. 초기 제품 데이터는 CSV 형태로 제공되며, 이를 기반으로 데이터베이스 스키마를 설계합니다.\n\n## 2. 기술 스택\n\n| 범주 | 기술 / 라이브러리 | 선정 사유 (본 프로젝트에 적합한 이유) |\n| --- | --- | --- |\n| 프레임워크 | Next.js (App Router) | 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 지원하여 초기 로딩 성능과 검색엔진 최적화(SEO) 요구사항을 동시에 충족합니다. Vercel 배포에 최적화되어 있습니다. |\n| 데이터베이스 & 백엔드 | Supabase | PostgreSQL DB, 인증, 스토리지, Edge Function을 통합 제공하는 BaaS(Backend as a Service)로, 별도 백엔드 서버 구축 없이 빠르게 개발이 가능합니다. RLS(Row Level Security)로 안전한 데이터 접근 제어를 구현합니다. |\n| UI & 스타일링 | Tailwind CSS | 유틸리티 우선 접근 방식으로 신속하고 일관된 반응형 UI를 구축할 수 있습니다. 커스텀 디자인 시스템 구현이 용이하여 브랜드 정체성을 유지하기에 적합합니다. |\n| 상태 관리 | Zustand | Redux 대비 코드량이 적고 사용법이 간단하여 필터 상태 등 클라이언트 사이드 상태를 최소한의 복잡도로 관리할 수 있습니다. |\n| 데이터 페칭 | SWR | Next.js 개발사인 Vercel에서 제작한 라이브러리로, 캐싱, 재검증, 포커스 추적 등 데이터 동기화를 자동으로 처리하여 사용자 경험을 향상시킵니다. |\n| 배포 & 인프라 | Vercel | Next.js에 최적화된 배포 플랫폼으로, GitHub 연동을 통해 CI/CD 파이프라인을 자동으로 구성하고 글로벌 CDN을 기본 제공하여 빠른 콘텐츠 전송을 보장합니다. |\n| 관리자 페이지 | Next.js (Custom App) | Supabase의 기본 테이블 편집기 대신, 비개발자 사용성에 초점을 맞춘 별도의 Next.js 애플리케이션을 구축합니다. 직관적인 UI와 CSV 일괄 업로드/검증 기능을 제공하여 운영 효율을 극대화합니다. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **Next.js 프론트엔드 애플리케이션**: 사용자가 직접 상호작용하는 웹사이트입니다. Vercel에 배포되며, 제품 목록, 상세 페이지, 문의 양식 등의 UI를 렌더링합니다. 서버 컴포넌트를 활용해 Supabase에서 직접 데이터를 조회하고, 클라이언트 컴포넌트에서 동적 기능을 처리합니다.\n- **Supabase 백엔드 서비스**: 올인원 백엔드 플랫폼으로, 다음과 같은 하위 요소로 구성됩니다.\n    - **PostgreSQL 데이터베이스**: 제품, 카테고리, 파라미터, 사용자 데이터 등을 저장합니다. 필터링 성능을 위해 주요 조회 컬럼에 인덱스를 적용합니다.\n    - **Supabase Auth**: 사용자 인증 및 역할 기반 접근 제어(RBAC)를 관리합니다.\n    - **Supabase Storage**: 제품 데이터시트, 이미지 등 정적 파일을 저장하고 CDN을 통해 제공합니다.\n    - **Supabase Edge Functions**: 대용량 CSV 파일 처리, 외부 API 연동 등 복잡한 비즈니스 로직을 서버리스 함수로 실행하여 프론트엔드 부담을 줄입니다.\n- **커스텀 관리자 CMS**: 비개발자 관리자를 위한 별도의 Next.js 애플리케이션입니다. Supabase API를 호출하여 데이터를 관리하며, 제품 정보의 대량 생성/수정/삭제(CRUD) 기능을 직관적인 UI로 제공합니다.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    subgraph \"사용자 영역\"\n        User[B2B 구매 담당자/엔지니어]\n        Admin[바이렉스 관리자]\n    end\n\n    subgraph \"Vercel 플랫폼\"\n        NextApp[Next.js B2B 포털]\n        AdminCMS[Next.js 관리자 CMS]\n    end\n\n    subgraph \"Supabase 플랫폼\"\n        DB[(PostgreSQL 데이터베이스)]\n        Auth[인증 서비스]\n        Storage[파일 스토리지]\n        EdgeFuncs[Edge Functions]\n    end\n\n    User -- HTTPS --> NextApp\n    Admin -- HTTPS --> AdminCMS\n\n    NextApp -- API/SDK --> Auth\n    NextApp -- API/SDK --> DB\n    NextApp -- API/SDK --> Storage\n\n    AdminCMS -- API/SDK --> Auth\n    AdminCMS -- API/SDK --> DB\n    AdminCMS -- API/SDK --> Storage\n    AdminCMS -- API/SDK --> EdgeFuncs\n\n```\n- **사용자 상호작용**: 일반 사용자는 Next.js로 구축된 B2B 포털에 접속하며, 관리자는 별도로 제공되는 관리자 CMS에 접속합니다.\n- **프론트엔드-백엔드 통신**: Next.js 애플리케이션(포털 및 CMS)은 Supabase의 JavaScript SDK를 사용하여 데이터베이스 조회, 파일 관리, 인증 등의 기능을 안전하게 호출합니다.\n- **비즈니스 로직 처리**: 대용량 CSV 업로드와 같은 복잡한 작업은 관리자 CMS가 Supabase Edge Function을 호출하여 비동기적으로 처리합니다. 이를 통해 프론트엔드 UI가 멈추는 현상을 방지합니다.\n\n### 코드 구조 및 컨벤션\n**도메인 주도 구조화 전략**\n- **도메인 분리**: 비즈니스 도메인(제품, 사용자, 주문 등)을 기준으로 코드를 구성하여 응집도를 높이고 결합도를 낮춥니다.\n- **계층 기반 아키텍처**: 각 도메인 내부는 `presentation`(UI 컴포넌트), `application`(서비스 로직), `domain`(타입/엔티티)으로 계층을 분리합니다.\n- **기능 기반 모듈**: 특정 기능과 관련된 파일(예: 필터링 로직, 컴포넌트, 훅)을 하나의 폴더에 그룹화합니다.\n- **공유 컴포넌트**: 여러 도메인에서 공통으로 사용되는 유틸리티, 타입, UI 요소는 `shared` 또는 `lib` 디렉토리에서 관리합니다.\n\n**범용 파일 및 폴더 구조**\n```\n/\n├── src/\n│   ├── app/                  # Next.js App Router (페이지 및 레이아웃)\n│   │   ├── (admin)/          # 관리자 페이지 그룹\n│   │   │   └── dashboard/\n│   │   ├── (portal)/         # 사용자 포털 그룹\n│   │   │   ├── products/\n│   │   │   │   ├── [slug]/page.tsx\n│   │   │   │   └── page.tsx\n│   │   │   └── layout.tsx\n│   │   └── api/              # API 라우트 핸들러\n│   ├── components/           # 공유 UI 컴포넌트 (Button, Input 등)\n│   ├── domains/              # 핵심 비즈니스 도메인\n│   │   ├── product/\n│   │   │   ├── components/   # 제품 관련 UI 컴포넌트 (ProductCard, FilterPanel)\n│   │   │   ├── services/     # 제품 데이터 처리 로직 (API 호출 등)\n│   │   │   └── types/        # 제품 관련 타입 정의 (Product, Parameter)\n│   │   └── user/\n│   ├── lib/                  # 공유 라이브러리 및 유틸리티 (Supabase 클라이언트 등)\n│   ├── styles/               # 전역 스타일\n│   └── types/                # 전역 타입 정의\n├── public/                   # 정적 에셋 (이미지, 폰트)\n└── tailwind.config.ts        # Tailwind CSS 설정\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: 제품 목록과 같이 동적인 데이터는 Next.js 서버 컴포넌트가 Supabase에서 직접 데이터를 가져와 렌더링합니다. 사용자의 필터링 조작과 같은 상호작용은 클라이언트 컴포넌트에서 SWR을 사용해 API 라우트를 호출하여 비동기적으로 처리합니다.\n- **데이터베이스 상호작용**: `supabase-js` 클라이언트를 통해 타입-세이프하게 데이터베이스와 통신합니다. 모든 데이터 접근은 Supabase의 RLS(Row Level Security) 정책을 거쳐 인가된 사용자만 데이터에 접근할 수 있도록 합니다.\n- **외부 서비스 연동**: 이메일 발송(SendGrid) 등 외부 서비스 연동은 보안을 위해 서버 측(API Routes 또는 Edge Functions)에서 처리합니다.\n- **데이터 동기화**: 제품 필터링 상태는 URL 쿼리 파라미터에 저장하여 사용자가 현재 필터 상태를 북마크하거나 다른 사람에게 공유할 수 있도록 합니다.\n\n## 4. 성능 및 최적화 전략\n- **데이터베이스 최적화**: 제품 테이블에서 자주 사용되는 필터링 조건(예: `partnumber`, `series`,",
      "writedAt": "2025-07-30T04:09:10.138Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-30T04:09:10.138Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-30T04:09:10.138Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-30T04:09:10.138Z"
    }
  ]
}